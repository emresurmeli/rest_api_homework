#!/usr/bin/env node
// Generated by LiveScript 1.2.0
var optionator, daemon, cluster, fs, net, util, os, winston, moment, pidusage, async, prettysize, daemonName, version, workers, processExists, writePidFile, removePidFile, removeSocketFile, workerLogger, workerMsg, forkWorker, forkWorkers, delayedKill, killAllWorkers, shutdown, terminate, reload, logLevels, opts, clOptions, logTransports, gatherStats, logger, x, log, i$, len$, level, pid, cli, controlServer, attachEvents;
import$(global, require('prelude-ls'));
optionator = require('optionator');
daemon = require('daemon');
cluster = require('cluster');
fs = require('fs');
net = require('net');
util = require('util');
os = require('os');
winston = require('winston');
moment = require('moment');
pidusage = require('pidusage');
async = require('async');
prettysize = require('prettysize');
console.log(process.argv.join(" "));
daemonName = 'node-daemon';
version = '0.0.2';
workers = {};
processExists = function(pid){
  var e;
  try {
    process.kill(pid, 0);
  } catch (e$) {
    e = e$;
    return false;
  }
  return true;
};
writePidFile = function(){
  return fs.writeFileSync(clOptions.pidfile, process.pid);
};
removePidFile = function(){
  var e;
  log.debug("Removing PID file");
  try {
    return fs.unlinkSync(clOptions.pidfile);
  } catch (e$) {
    e = e$;
  }
};
removeSocketFile = function(){
  var e;
  log.debug("Removing socket file");
  try {
    return fs.unlinkSync(clOptions.socket);
  } catch (e$) {
    e = e$;
  }
};
workerLogger = function(worker){
  return function(level){
    return function(msg){
      return log(level, "[" + worker.process.pid + "] " + msg.toString().replace(/\n$/, ''));
    };
  };
};
workerMsg = function(msg){
  return log.warning("[" + this.process.pid + ":msg] " + util.inspect(msg));
};
forkWorker = function(){
  var w;
  w = cluster.fork();
  return w.on('message', workerMsg);
};
forkWorkers = function(){
  var i$, to$, i, results$ = [];
  log.debug("Forking " + clOptions.workers + " workers...");
  for (i$ = 1, to$ = clOptions.workers; i$ <= to$; ++i$) {
    i = i$;
    results$.push(forkWorker());
  }
  return results$;
};
delayedKill = function(n, worker){
  var timeout;
  timeout = curry$(function(n, f){
    return setTimeout(f, n);
  });
  log.debug("Giving worker " + worker.process.pid + " " + n + " milliseconds to die...");
  return (function(w){
    return timeout(n, function(){
      if (w.state !== 'dead') {
        log.debug("KILLing " + w.process.pid);
        return w.kill();
      }
    });
  }.call(this, worker));
};
killAllWorkers = function(){
  var i;
  for (i in workers) {
    delayedKill(30000, workers[i]);
  }
  return cluster.disconnect();
};
shutdown = function(){
  var inProgress;
  inProgress = false;
  return function(msg){
    if (!inProgress) {
      log.info(msg);
      inProgress = true;
      return killAllWorkers();
    }
  };
}();
terminate = function(msg){
  removePidFile();
  removeSocketFile();
  return logger.log("info", msg, null, function(){
    return process.exit(0);
  });
};
reload = function(){
  killAllWorkers();
  return forkWorkers();
};
logLevels = Obj.keys(winston.config.syslog.levels).reverse();
opts = optionator({
  prepend: "Usage: " + daemonName + " [options]",
  append: 'Version {{version}}',
  options: [
    {
      option: 'help',
      alias: 'h',
      type: 'Boolean',
      description: 'Display help and exit',
      overrideRequired: 'true'
    }, {
      option: 'daemon',
      type: 'Boolean',
      'default': 'true',
      description: 'Daemonize (use --no-daemon to stay in foreground)'
    }, {
      option: 'loglevel',
      alias: 'v',
      type: 'String',
      'enum': logLevels,
      'default': 'info',
      description: "Set log level"
    }, {
      option: 'logfile',
      alias: 'l',
      type: 'String',
      'default': "./" + daemonName + ".log",
      description: "Log file"
    }, {
      option: 'errorlog',
      alias: 'e',
      type: 'String',
      'default': "./" + daemonName + ".err",
      description: "Error log"
    }, {
      option: 'pidfile',
      alias: 'p',
      type: 'String',
      'default': "./" + daemonName + ".pid",
      description: "PID file"
    }, {
      option: 'socket',
      alias: 's',
      type: 'String',
      'default': "./" + daemonName + ".socket",
      description: "Path to controlling socket"
    }, {
      option: 'workers',
      alias: 'n',
      type: 'Int',
      description: "How many workers to fork (defaults to # of CPUs)",
      'default': os.cpus().length.toString()
    }, {
      option: 'worker',
      alias: 'w',
      type: 'String',
      required: 'true',
      description: "Path to worker"
    }, {
      option: 'user',
      alias: 'u',
      type: "String | Int"
    }, {
      option: 'group',
      alias: 'g',
      type: "String | Int"
    }
  ]
});
clOptions = opts.parse(process.argv);
logTransports = {
  daemon: [
    new winston.transports.File({
      name: '#debug',
      level: clOptions.loglevel,
      filename: clOptions.logfile,
      json: false,
      colorize: true,
      timestamp: function(){
        return moment().format("YYYY-MM-DD HH:MM:SS.SSS ZZ");
      }
    }), new winston.transports.File({
      name: '#error',
      level: 'error',
      filename: clOptions.errorlog,
      json: false,
      handleExceptions: true
    }), new winston.transports.Console({
      level: clOptions.loglevel,
      colorize: true
    })
  ],
  commandLine: [new winston.transports.Console({
    level: clOptions.loglevel,
    colorize: true
  })]
};
gatherStats = function(pids, cb){
  var pidStats;
  pidStats = function(pid, cb){
    return pidusage(pid, function(err, stats){
      if (err) {
        return cb(err, null);
      } else {
        return cb(err, {
          pid: pid,
          stats: {
            cpu: stats.cpu.toFixed(2) + "%",
            memory: prettysize(stats.memory),
            role: process.pid === pid ? 'master' : 'worker',
            state: process.pid === pid
              ? 'running'
              : workers[pid].state
          }
        });
      }
    });
  };
  return async.map(pids, pidStats, function(err, stats){
    var i;
    return cb(err, (function(){
      var i$, ref$, len$, results$ = {};
      for (i$ = 0, len$ = (ref$ = stats).length; i$ < len$; ++i$) {
        i = ref$[i$];
        results$[i.pid] = i.stats;
      }
      return results$;
    }()));
  });
};
if (clOptions.help) {
  console.log(opts.generateHelp({
    interpolate: {
      version: version
    }
  }));
  process.exit(0);
}
logger = new winston.Logger({
  levels: (function(){
    var results$ = {};
    for (x in logLevels) {
      results$[logLevels[x]] = x;
    }
    return results$;
  }()),
  transports: logTransports[clOptions.daemon ? 'daemon' : 'commandLine']
});
log = curry$(function(level, msg){
  return bind$(logger, 'log')(level, msg);
});
for (i$ = 0, len$ = logLevels.length; i$ < len$; ++i$) {
  level = logLevels[i$];
  log[level] = log(level);
}
console.log("Starting " + daemonName + " " + version);
if (clOptions.group != null) {
  log.notice("Setting GID to " + clOptions.group);
  (function(n){
    process.setgid(isNaN(n) ? clOptions.group : n);
  }.call(this, parseInt(clOptions.group)));
}
if (clOptions.user != null) {
  log.notice("Setting UID to " + clOptions.user);
  (function(n){
    process.setuid(isNaN(n) ? clOptions.user : n);
  }.call(this, parseInt(clOptions.user)));
}
if (fs.existsSync(clOptions.pidfile)) {
  pid = parseInt(
  fs.readFileSync(clOptions.pidfile).toString());
  if (processExists(pid)) {
    log.info("Pidfile exists; Process " + pid + " exists. Exiting.");
    process.exit(1);
  } else {
    log.info("Pid file exists (" + pid + "), but no such process is running. Continuing.");
  }
}
cli = function(socket){
  socket.on('data', function(data){
    var cmd;
    cmd = function(it){
      return it.replace(/^\s+/, '');
    }(
    function(it){
      return it.replace(/\s+$/, '');
    }(
    data.toString()));
    log('info', "Command received via control socket: `" + cmd + "`");
    switch (cmd) {
    case 'status':
      return socket.end("status: running " + Object.keys(cluster.workers).length + " workers: " + keys(workers).join(", "));
    case 'fullstatus':
      return gatherStats(Obj.keys(workers).concat(process.pid), function(err, results){
        var pid;
        for (pid in results) {
          socket.write(pid + " " + results[pid].role + " " + results[pid].state + " " + results[pid].cpu + " " + results[pid].memory + "\n");
        }
        return socket.end();
      });
    case 'reload':
      log('info', "Reload request received via control socket.");
      socket.end("Reloading...\n");
      return reload();
    case 'exit':
      socket.end("Received termination request");
      return shutdown("Termination request received via control socket.");
    case 'gc':
      socket.end("GC!");
      return global.gc();
    default:
      return socket.end("Unknown command: `" + cmd + "`\n");
    }
  });
};
removeSocketFile();
controlServer = net.createServer(cli).listen(clOptions.socket);
writePidFile();
process.title = daemonName + " [master]";
cluster.setupMaster({
  exec: clOptions.worker,
  silent: true
});
attachEvents = function(obj, events){
  var e;
  for (e in events) {
    obj.on(e, events[e]);
  }
};
attachEvents(cluster, {
  listening: function(worker, address){
    return log.info("Worker " + worker.process.pid + " is listening on " + address.address + ":" + address.port);
  },
  fork: function(worker){
    workers[worker.process.pid] = worker;
    return log.debug("Forked new worker " + worker.process.pid);
  },
  online: function(worker){
    log.debug("Worker " + worker.process.pid + " online");
    worker.process.stdout.on('data', workerLogger(worker)('info'));
    return worker.process.stderr.on('data', workerLogger(worker)('error'));
  },
  disconnect: function(worker){
    return log.debug("Worker " + worker.process.pid + " disconnected");
  },
  exit: function(worker){
    var ref$;
    if (worker.suicide) {
      log.debug("Worker " + worker.process.pid + " killed itself. Not restarting it.");
    }
    if (worker.process.signalCode) {
      log.error("Worker " + worker.process.pid + " exited on signal " + worker.process.signalCode);
    } else {
      log.error("Worker " + worker.process.pid + " exited with code " + worker.process.exitCode);
    }
    delete workers[worker.process.pid];
    if (!(worker.suicide || ((ref$ = worker.process.exitCode) === 1 || ref$ === 8))) {
      forkWorker();
    }
    if (Obj.keys(workers).length === 0) {
      return terminate("Last worker exited. Terminating.");
    }
  }
});
attachEvents(process, {
  SIGHUP: function(){
    log.info("SIGHUP received. Restarting all workers.");
    return reload();
  },
  SIGINT: function(){
    return shutdown("SIGINT received. Shutting down.");
  },
  SIGTERM: function(){
    return shutdown("SIGTERM received. Shutting down.");
  },
  uncaughtException: function(e){
    return logger.log('error', "===== UNCAUGHT EXCEPTION =====\n" + e.stack, null, function(){
      return process.exit(42);
    });
  }
});
if (clOptions.daemon) {
  console.log(daemonName + " " + version + " daemonizing...");
  daemon();
  logger.remove(winston.transports.Console);
}
forkWorkers();
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}