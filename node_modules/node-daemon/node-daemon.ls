global <<< require \prelude-ls
require! {
  \optionator \daemon \cluster \fs \net \util
  \os \winston \moment
  \pidusage \async \prettysize
}

console.log process.argv.join " "

daemon-name = \node-daemon
version = \0.0.2

workers = {}

process-exists = (pid) ->
  try process.kill pid, 0 catch e => return no
  return yes

write-pid-file = -> fs.write-file-sync cl-options.pidfile, process.pid
remove-pid-file = ->
  log.debug "Removing PID file"
  try fs.unlink-sync cl-options.pidfile catch e => void
    
remove-socket-file = ->
  log.debug "Removing socket file"
  try fs.unlink-sync cl-options.socket catch e => void
  
worker-logger = (worker) -> (level) -> (msg) ->
  log level, "[#{worker.process.pid}] #{msg.to-string!replace /\n$/, ''}"
  
worker-msg = (msg) -> log.warning "[#{@process.pid}:msg] #{util.inspect msg}"

fork-worker = ->
  w = cluster.fork!
  w.on \message worker-msg

fork-workers = ->
  log.debug "Forking #{cl-options.workers} workers..."
  for i from 1 to cl-options.workers => fork-worker!
  
delayed-kill = (n, worker) ->
  timeout = (n, f) --> set-timeout f, n
  log.debug "Giving worker #{worker.process.pid} #{n} milliseconds to die..."
  let w = worker
    timeout n, ->
      unless w.state is \dead
        log.debug "KILLing #{w.process.pid}"
        w.kill!

kill-all-workers = ->
  for i of workers => delayed-kill 30_000ms workers[i]
  cluster.disconnect!
  
shutdown = do ->
  in-progress = no
  (msg) ->
    unless in-progress
      log.info msg
      in-progress := yes
      kill-all-workers!

terminate = (msg) ->
  remove-pid-file!
  remove-socket-file!
  <- logger.log "info", msg, null # Flush the logs before really shutting down
  process.exit 0
  
reload = ->
  kill-all-workers!
  fork-workers! # do not wait for workers to die, fork new immediately

log-levels = Obj.keys winston.config.syslog.levels .reverse!

opts = optionator do
  prepend: "Usage: #{daemon-name} [options]"
  append: 'Version {{version}}'

  options:
    * option: \help alias: \h type: \Boolean
      description: 'Display help and exit'
      override-required: \true
    
    * option: \daemon
      type: \Boolean default: \true
      description: 'Daemonize (use --no-daemon to stay in foreground)'
    
    * option: \loglevel alias: \v
      type: \String enum: log-levels
      default: \info
      description: "Set log level"
    
    * option: \logfile alias: \l
      type: \String
      default: "./#{daemon-name}.log"
      description: "Log file"
    
    * option: \errorlog alias: \e
      type: \String
      default: "./#{daemon-name}.err"
      description: "Error log"
    
    * option: \pidfile alias: \p
      type: \String
      default: "./#{daemon-name}.pid"
      description: "PID file"
    
    * option: \socket alias: \s
      type: \String
      default: "./#{daemon-name}.socket"
      description: "Path to controlling socket"
    
    * option: \workers alias: \n type: \Int
      description: "How many workers to fork (defaults to # of CPUs)"
      default: os.cpus!length.to-string!
      
    * option: \worker alias: \w type: \String
      required: 'true'
      description: "Path to worker"
        
    * option: \user alias: \u
      type: "String | Int"
      
    * option: \group alias: \g
      type: "String | Int"
        
cl-options = opts.parse process.argv

log-transports = # If started as a daemon, log to files, else to console
  daemon: 
    * new winston.transports.File do
        name: \#debug # just to make Winston happy
        level: cl-options.loglevel
        filename: cl-options.logfile
        json: no
        colorize: yes
        timestamp: -> moment!format "YYYY-MM-DD HH:MM:SS.SSS ZZ"
    * new winston.transports.File do
        name: \#error # just to make Winston happy
        level: \error
        filename: cl-options.errorlog
        json: no
        handle-exceptions: yes
    * new winston.transports.Console level: cl-options.loglevel, colorize: yes
  
  command-line: 
    * new winston.transports.Console level: cl-options.loglevel, colorize: yes
    ...
    
gather-stats = (pids, cb) ->
  pid-stats = (pid, cb) ->
    (err, stats) <- pidusage pid
    if err then cb err, null
    else
      cb err, do
        pid: pid
        stats: 
          cpu: "#{stats.cpu.to-fixed 2}%"
          memory: prettysize stats.memory 
          role: if process.pid is pid then \master else \worker
          state: if process.pid is pid then \running else workers[pid].state

  async.map pids, pid-stats, (err, stats) -> cb err, { [i.pid, i.stats ] for i in stats }

if cl-options.help
  console.log opts.generate-help interpolate: version: version
  process.exit 0
  
logger = new winston.Logger do
  levels: { [log-levels[x], x] for x of log-levels }
  transports:
    log-transports[ if cl-options.daemon then \daemon else \commandLine ]
                              
log = (level, msg) --> logger~log level, msg
for level in log-levels => log[level] = log level

console.log "Starting #{daemon-name} #{version}"

if cl-options.group?
  log.notice "Setting GID to #{cl-options.group}"
  let n = parse-int cl-options.group
    process.setgid if isNaN n then cl-options.group else n

if cl-options.user?
  log.notice "Setting UID to #{cl-options.user}"
  let n = parse-int cl-options.user
    process.setuid if isNaN n then cl-options.user else n
    
if fs.exists-sync cl-options.pidfile
  pid = fs.read-file-sync cl-options.pidfile .to-string! |> parse-int

  if process-exists pid
    log.info "Pidfile exists; Process #{pid} exists. Exiting."
    process.exit 1
  else
    log.info "Pid file exists (#{pid}), but no such process is running. Continuing."

cli = (socket) !->
  socket.on \data (data) ->
    cmd = data.to-string! |> (.replace /\s+$/, '') |> (.replace /^\s+/, '')

    log \info "Command received via control socket: `#{cmd}`"
    switch cmd
    | \status
      socket.end "status: running #{Object.keys(cluster.workers).length} workers: #{(keys workers).join ", "}"
    | \fullstatus
      (err, results) <- gather-stats (Obj.keys workers) ++ process.pid
      for pid of results
        socket.write "#{pid} #{results[pid].role} #{results[pid].state} #{results[pid].cpu} #{results[pid].memory}\n"

      socket.end!
          
    | \reload
        log \info "Reload request received via control socket."
        socket.end "Reloading...\n"
        reload!
    | \exit 
        socket.end "Received termination request"
        shutdown "Termination request received via control socket."
    | \gc
        socket.end "GC!"
        global.gc!
    | otherwise 
      socket.end "Unknown command: `#{cmd}`\n"
      
remove-socket-file!
control-server = net.create-server cli
  .listen cl-options.socket
write-pid-file!
process.title = "#{daemon-name} [master]"

cluster.setup-master do
  exec: cl-options.worker
  silent: yes

attach-events = (obj, events) !-> for e of events => obj.on e, events[e]

cluster `attach-events` do
  listening : (worker, address) ->
    log.info "Worker #{worker.process.pid} is listening on #{address.address}:#{address.port}"
  fork: (worker) ->
    workers[worker.process.pid] = worker
    log.debug "Forked new worker #{worker.process.pid}"
  online : (worker) ->
    log.debug "Worker #{worker.process.pid} online"
    worker.process.stdout.on \data (worker-logger worker) \info
    worker.process.stderr.on \data (worker-logger worker) \error
  disconnect : (worker) ->
    log.debug "Worker #{worker.process.pid} disconnected"
  exit : (worker) ->
    if worker.suicide => log.debug "Worker #{worker.process.pid} killed itself. Not restarting it."
    if worker.process.signal-code => log.error "Worker #{worker.process.pid} exited on signal #{worker.process.signal-code}"
    else log.error "Worker #{worker.process.pid} exited with code #{worker.process.exitCode}"
    
    delete workers[worker.process.pid]
    fork-worker! unless worker.suicide or worker.process.exit-code in [1, 8]
    
    if (Obj.keys workers .length) is 0
      terminate "Last worker exited. Terminating."

process `attach-events` do
  SIGHUP : ->
    log.info "SIGHUP received. Restarting all workers."
    reload!
  SIGINT : -> shutdown "SIGINT received. Shutting down."
  SIGTERM : -> shutdown "SIGTERM received. Shutting down."
  uncaught-exception : (e) ->
    <- logger.log \error "===== UNCAUGHT EXCEPTION =====\n#{e.stack}" null
    process.exit 42
    
if cl-options.daemon
  console.log "#{daemon-name} #{version} daemonizing..."
  daemon!
  logger.remove winston.transports.Console
  
fork-workers!